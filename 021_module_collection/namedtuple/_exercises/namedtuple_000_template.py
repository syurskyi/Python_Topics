# # # # -*- coding: utf-8 -*-
#
# # namedtuple
#
# # В данном разделе мы сфокусируемся на namedtuple, который можно использовать для замены кортежей Python.
# # Разумеется, namedtuple действует не так примитивно, как может показаться на первый взгляд. Я видел некоторых
# # программистов, которые используют его как struct. Если вы не работали с языком, в котором есть struct, тогда
# # нужно объяснить немного подробнее. Когда мы говорим о struct, мы имеем ввиду сложный тип данных, который
# # группирует список переменных под одним именем. Давайте взглянем на пример того, как создается namedtuple,
# # чтобы понять принцип его работы:

from collections import namedtuple

Parts = namedtuple('Parts', 'id_num desc cost amount')
auto_parts = Parts(
    id_num='1234',
    desc='Ford Engine',
    cost=1200.00,
    amount=10
)

print(auto_parts.id_num)
#
# # Здесь мы импортировали namedtuple из модуля c... Далее мы вызываем namedtuple, который вернет новый
# # наследуемый класс кортежа, но с названными полями. Так что фактически мы создали новый класс кортежа.
# # Обратите внимание на то, что у нас имеется странная строка в качестве второго аргумента. Это список свойств,
# # который мы хотим создать, разделенный пробелами. Теперь, когда у нас появился чудесный новый класс, давайте
# # создадим его экземпляр! Как вы видите выше, это делается так же, как когда мы создаем объект auto_parts.
# # Теперь мы можем дать auto_parts доступ к различным предметам, используя точечную нотацию, так как теперь они
# # являются свойствами нашего класса Parts. Одно из преимуществ использования namedtuple над обычным кортежем
# # заключается в том, что вам не нужно отслеживать индекс каждого объекта, так как каждый объект назван и доступен
# # через свойство класса. Давайте взглянем на разницу на примере кода:

auto_parts = ('1234', 'Ford Engine', 1200.00, 10)
print(auto_parts[2]) # выводим цену: 1200.0

id_num, desc, cost, ammount = auto_parts
print(id_num)  # '1234'

# # В данном коде мы создали обычный кортеж и передали доступ к цене на двигатель автомобиля, указав Python необходимый
# # нам индекс. Как альтернативный способ, мы можем также извлечь все что есть из кортежа используя множественное
# # назначение. Лично я предпочитаю в таких случаях использовать namedtuple, так как это проще для мозга,
# # и вы можете использовать метод dir() для проверки кортежа и нахождения его свойств. Попробуйте сами, и посмотрите,
# # что у вас выйдет. Как-то раз я искал способ конвертировать словарь Python в объект и наткнулся на код,
# # который делает что-то вроде этого:

from collections import namedtuple

Parts ={
    'id_num':'1234',
    'desc':'Ford Engine',
    'cost':1200.00,
    'amount':10
}

parts = namedtuple('Parts', Parts.keys())(**Parts)
print(parts)
# # Parts(amount=10, cost=1200.0, id_num='1234', desc='Ford Engine')
#
# # Это немного странный код, так что давайте разберем его по кусочкам. В первой строке мы импортируем namedtuple,
# # как и раньше. Далее, мы создаем словарь Parts. Пока все логично. Теперь переходим к странной части.
# # Здесь мы создаем наш класс namedtuple и называем его ‘Parts’. Второй аргумент – это список ключей из нашего словаря.
# # Последняя часть этой странной части кода: (Parts)**. Двойная звездочка означает, что мы вызываем наш класс при помощи
# # ключевых аргументов, в нашем случае это словарь. Мы можем разделить эту строку на две части, для большей
# # гигиеничности:
#
# parts _ n..t.. 'Parts' P__.ke..
# print p..
# # <class '__main__.Parts'>
#
# auto_parts _ p.. 00P..
# print a.._p..
# # Parts(amount=10, cost=1200.0, id_num='1234', desc='Ford Engine')
#
# # Здесь мы делаем то же, что и раньше, за исключением того, что сначала мы создаем класс, затем мы вызываем этот
# # класс при помощи словаря для создания объекта. Еще один момент, который я хотел бы прояснить: namedtuple также
# # принимает аргументы verbose и rename.
# #
# #     Аргумент verbose – это флаг, который выводит определение класса непосредственно перед его построением,
# #     если вы укажете его значение как True.
# #     Аргумент rename весьма полезен в тех случаях, когда вы создаете namedtuple из базы данных, или какой-нибудь
# #     другой системы, которую ваша программа не контролирует для автоматического переименования свойств для вас.
# #
# # С этого момента вы должны быть достаточно ознакомлены с namedtuple для личного пользования, так что теперь
# # мы перейдем к OrderedDict.
#

