# namedtuple

# В данном разделе мы сфокусируемся на namedtuple, который можно использовать для замены кортежей Python.
# Разумеется, namedtuple действует не так примитивно, как может показаться на первый взгляд. Я видел некоторых
# программистов, которые используют его как struct. Если вы не работали с языком, в котором есть struct, тогда
# нужно объяснить немного подробнее. Когда мы говорим о struct, мы имеем ввиду сложный тип данных, который
# группирует список переменных под одним именем. Давайте взглянем на пример того, как создается namedtuple,
# чтобы понять принцип его работы:

from collections import namedtuple

Parts = namedtuple('Parts', 'id_num desc cost amount')
auto_parts = Parts(
    id_num='1234',
    desc='Ford Engine',
    cost=1200.00,
    amount=10
)

print(auto_parts.id_num)

# Здесь мы импортировали namedtuple из модуля collections. Далее мы вызываем namedtuple, который вернет новый
# наследуемый класс кортежа, но с названными полями. Так что фактически мы создали новый класс кортежа.
# Обратите внимание на то, что у нас имеется странная строка в качестве второго аргумента. Это список свойств,
# который мы хотим создать, разделенный пробелами. Теперь, когда у нас появился чудесный новый класс, давайте
# создадим его экземпляр! Как вы видите выше, это делается так же, как когда мы создаем объект auto_parts.
# Теперь мы можем дать auto_parts доступ к различным предметам, используя точечную нотацию, так как теперь они
# являются свойствами нашего класса Parts. Одно из преимуществ использования namedtuple над обычным кортежем
# заключается в том, что вам не нужно отслеживать индекс каждого объекта, так как каждый объект назван и доступен
# через свойство класса. Давайте взглянем на разницу на примере кода:

auto_parts = ('1234', 'Ford Engine', 1200.00, 10)
print(auto_parts[2]) # выводим цену: 1200.0

id_num, desc, cost, amount = auto_parts
print(id_num)  # '1234'

# В данном коде мы создали обычный кортеж и передали доступ к цене на двигатель автомобиля, указав Python необходимый
# нам индекс. Как альтернативный способ, мы можем также извлечь все что есть из кортежа используя множественное
# назначение. Лично я предпочитаю в таких случаях использовать namedtuple, так как это проще для мозга,
# и вы можете использовать метод dir() для проверки кортежа и нахождения его свойств. Попробуйте сами, и посмотрите,
# что у вас выйдет. Как-то раз я искал способ конвертировать словарь Python в объект и наткнулся на код,
# который делает что-то вроде этого:

from collections import namedtuple

Parts = {
    'id_num':'1234',
    'desc':'Ford Engine',
    'cost':1200.00,
    'amount':10
}

parts = namedtuple('Parts', Parts.keys())(**Parts)
print(parts)
# Parts(amount=10, cost=1200.0, id_num='1234', desc='Ford Engine')

# Это немного странный код, так что давайте разберем его по кусочкам. В первой строке мы импортируем namedtuple,
# как и раньше. Далее, мы создаем словарь Parts. Пока все логично. Теперь переходим к странной части.
# Здесь мы создаем наш класс namedtuple и называем его ‘Parts’. Второй аргумент – это список ключей из нашего словаря.
# Последняя часть этой странной части кода: (Parts)**. Двойная звездочка означает, что мы вызываем наш класс при помощи
# ключевых аргументов, в нашем случае это словарь. Мы можем разделить эту строку на две части, для большей
# гигиеничности:

parts = namedtuple('Parts', Parts.keys())
print(parts)
# <class '__main__.Parts'>

auto_parts = parts(**Parts)
print(auto_parts)
# Parts(amount=10, cost=1200.0, id_num='1234', desc='Ford Engine')

# Здесь мы делаем то же, что и раньше, за исключением того, что сначала мы создаем класс, затем мы вызываем этот
# класс при помощи словаря для создания объекта. Еще один момент, который я хотел бы прояснить: namedtuple также
# принимает аргументы verbose и rename.
#
#     Аргумент verbose – это флаг, который выводит определение класса непосредственно перед его построением,
#     если вы укажете его значение как True.
#     Аргумент rename весьма полезен в тех случаях, когда вы создаете namedtuple из базы данных, или какой-нибудь
#     другой системы, которую ваша программа не контролирует для автоматического переименования свойств для вас.
#
# С этого момента вы должны быть достаточно ознакомлены с namedtuple для личного пользования, так что теперь
# мы перейдем к OrderedDict.

