_____ _, t__


___ worker(i
    n = i + 1
    print(f'Запуск потока №{n}')
    t__.s..(2)
    print(f'Поток №{n} выполнился.')


___ i __ r..(2
    thread = _.?(t.. worker, a.. (i,))
    thread.start()
    # если присоединять 'thread.join()' потоки здесь,
    # то они будут запускаться по очереди, т.к.
    # основной поток программы будет ждать конца
    # выполнения присоединенного потока, прежде
    # чем запустить следующий

print('Потоки запущены, основной поток программы так же выполняется')

# получаем экземпляр основного потока
main_thread = _.main_thread()

# объединим потоки, что бы дождаться их выполнения
___ t __ _.enumerate(
    # Список 'threading.enumerate()' включает в себя основной
    # поток и т.к. присоединение основного потока самого к себе
    # вызывает взаимоблокировку, то его необходимо пропустить
    __ t is main_thread:
        continue
    print(f'Ожидание выполнения потока {t.name}')
    t.join()

print('Основной поток программы после ожидания продолжает работу')

# Запуск потока №1
# Запуск потока №2
# Потоки запущены, основной поток программы так же выполняется
# Ожидание выполнения потока Thread-1
# Поток №2 выполнился.
# Поток №1 выполнился.
# Ожидание выполнения потока Thread-2
# Основной поток программы после ожидания продолжает работу