import threading, queue, pathlib

event_reader = threading.Event()
# очередь с названием файлов
files_queue = queue.Queue()
# очередь с обработанными данными
data_queue = queue.Queue()

path = pathlib.Path('.')
# каталог с файлами
test_dir = 'test_dir'
path_dir = path.joinpath(test_dir)
# список файлов
list_files = path_dir.glob('*.txt')


def writer(wr_file):  # ПИСАТЕЛЬ
    while True:
        # ожидаем получение данных
        if data_queue.empty():
            # !!!!! проверяем: живы ли потоки читателей `reader()` !!!!!
            if event_reader.is_set():
                # если очередь пуста и все
                # читатели завершили работу ТО:
                print('Все файлы объединены.')
                # конец работы - завершаем цикл
                break
        else:
            # как только поступили данные
            # извлекаем их и записываем
            r_file, data = data_queue.get()
            # пишем данные
            print(f'Пишем файл {r_file.name}')
            with open(wr_file, 'a+') as fw:
                # дописываем в начало файла его имя
                fw.w.. _*\n\nИмя файла ? \n\n
                # пишем сами данные
                ?.w.. ?


___ reader i  # ЧИТАТЕЛЬ
    # здесь читаем и обрабатываем данные файлов
    w__ T..
        # Проверяем, есть ли файлы в очереди
        __ f__.e..
            print _*Поток ? завершен.
            # выходим из цикла
            _____
        # Получаем имя файла из очереди
        r_file  f__.g..
        print _* Th ?: Читаем  файл ?.n..
        w__ o__ ? _  __ fr
            # читаем построчно
            data   # list
            ___ line __ ?
                # обрабатываем данные построчно
                line  ?.r.. 'у', '0' .l..
                # складываем обработанные строки в список
                ?.a.. ?
            # объединяем данные в текст
            data_all  ''.j.. ?
            # Ставим в очередь кортеж (имя_файла, данные)
            d__.p.. ? ?

        # !!!!! включаем управление событиями !!!!!




# создаем и заполняем очередь именами файлов
___ file __ ?
    ?.p.. ?

# общий файл c обработанными данными
write_file  'multi-thead-file.txt'

__ ?.e..
    print('НЕТ файлов для обработки.')
____
    # пишем в 1 поток. Если данные писать в несколько потоков,
    # то нужно еще использовать блокировщик threading.Lock()
    # или данные в итоговом файле будут перемешаны.
    tw = _.? t.. ? a.. ?
    ?.s..

    # читаем и обрабатываем в 2 потока
    threads # list
    ___ i __ r.. 2
        tr  _.? t.. ? a..  ? + 1
        ?.a.. ?
        ?.s..

    # ждем, когда все файлы прочитаются
    ?.j.. ___ ? __ ?
    # как все потоки reader() завершены
    # !!!!! скажем об этом writer() !!!!!
    ?.s..