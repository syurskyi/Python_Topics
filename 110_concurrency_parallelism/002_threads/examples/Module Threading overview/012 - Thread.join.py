import threading, time


def worker(i):
    n = i + 1
    print(f'Запуск потока №{n}')
    time.sleep(2)
    print(f'Поток №{n} выполнился.')


for i in range(2):
    thread = threading.Thread(target=worker, args=(i,))
    thread.start()
    # если присоединять 'thread.join()' потоки здесь,
    # то они будут запускаться по очереди, т.к.
    # основной поток программы будет ждать конца
    # выполнения присоединенного потока, прежде
    # чем запустить следующий

print('Потоки запущены, основной поток программы так же выполняется')

# получаем экземпляр основного потока
main_thread = threading.main_thread()

# объединим потоки, что бы дождаться их выполнения
for t in threading.enumerate():
    # Список 'threading.enumerate()' включает в себя основной
    # поток и т.к. присоединение основного потока самого к себе
    # вызывает взаимоблокировку, то его необходимо пропустить
    if t is main_thread:
        continue
    print(f'Ожидание выполнения потока {t.name}')
    t.join()

print('Основной поток программы после ожидания продолжает работу')

# Запуск потока №1
# Запуск потока №2
# Потоки запущены, основной поток программы так же выполняется
# Ожидание выполнения потока Thread-1
# Поток №2 выполнился.
# Поток №1 выполнился.
# Ожидание выполнения потока Thread-2
# Основной поток программы после ожидания продолжает работу