# -*- coding: utf-8 -*-

"""
Для классов нового типа доступен другой способ, решающий описанные ранее
проблемы. Существует специальный класс super, экземпляры которого являются
специальными прокси-объектами, привязанными к данной иерархии классов
и предоставляющими доступ к атрибутам следующего класса в линеаризации
того класса, в котором был создан объект super.

Таким образом, при помощи super можно получить доступ к атрибутам
и методам суперкласса, не называя его имени, причём это будет давать
корректные результаты даже при использовании множественного наследования.

В Python 2 в качестве параметров конструктора super передаются текующий
класс и экземпляр текущего класса. super ищет класс-предок в линеаризации
указанного класса и все обращения к атрибутам созданного объекта отображаются
на найденный класс, причём все методы привязаны к указанному объекту-экземпляру.

Пример: super(MyClass, self).method()

В Python 3 данные параметры можно не указывать. В таком случае будут
автоматически получены текущий класс и экземпляр. То есть, вызов
               super().method()
эквивалентен
               super(__class__, self).method()
"""


class Base(object):
    attr = 'Base attribute'

    def method(self):
        print('Base method, current class is', self.__class__.__name__)


class Child(Base):
    attr = 'Redefined attribute'

    def get_superclass_attr(self):
        return super().attr  # получение атрибута класса Base

    def method(self):  # переопределение метода
        super().method()  # вызов метода суперкласса
        print('Child method, current class is', self.__class__.__name__)


def main():
    print('Base:')
    print(Base.attr)
    base_instance = Base()
    base_instance.method()

    print()

    print('Child:')
    print(Child.attr)
    child_instance = Child()
    print(child_instance.get_superclass_attr())
    child_instance.method()

    print()

    # В большинстве языков программирования, в которых есть конструкция,
    # аналогичная super(), она может вызвана только внутри соответсвующего
    # метода подкласса, причём часто только в качестве его первого оператора
    # (впрочем, это наиболее типичный сценарий её использования).
    # В Python, как "побочный эффект" того, как работает его реализация super,
    # её можно вызвать где угодно, даже за пределами класса.
    super(Child, child_instance).method()


if __name__ == '__main__':
    main()