1. Считаем гласные

Напишите функцию count_vowels, которая принимает строку и возвращает количество гласных в ней.

Примеры вызовов и возвратов:

count_vowels('abcd') -> 1
count_vowels('abcdef') -> 2
count_vowels('bcd') -> 0

Примечание: речь идёт только о латинском алфавите.

2. Определяем FULL HOUSE

Написать функцию is_full_house, которая принимает список карт (руку, 5 карт иначе говоря) и определяет наличие комбинации Full House на руке. Возвращает True, если определён Full House, в противном случае - False.

Full House это когда из пяти карт 2 одного достоинства и 3 одного достоинства (но отличающегося от пары).

A - туз, J - валет, Q - дама, K - король, 2-10.

Примеры Full House: (A, A, Q, Q, Q), (10, 10, 10, J, J) 

Примеры вызовов и возвратов:

is_full_house(["A", "A", "A", "K", "K"]) ➞ True
is_full_house(["3", "J", "J", "3", "3"]) ➞ True
is_full_house(["10", "J", "10", "10", "10"]) ➞ False
is_full_house(["7", "J", "3", "4", "2"]) ➞ False

3. Уровни сладости

Разработать функцию sweetest_icecream, которая принимается список инстанций класса IceCream и возвращает "уровень сладости" самого сладкого мороженого.

"Уровень сладости" складывается из ароматизатора и количества посыпок. Сладость одной посыпки = 1, а сладость ароматизаторов считается по таблице:

Plain = 0
Vanilla = 5
ChocolateChip = 5
Strawberry = 10
Chocolate = 10

В функцию будут передаваться два аргумента: ароматизатор (как строка) и кол-во посыпок.

Примеры

ice1 = IceCream("Chocolate", 13)         # 10 + 13 = 23
ice2 = IceCream("Vanillla", 0)           # 5 + 0 = 5
ice3 = IceCream("Strawberry", 7)         # 10 + 7 = 17
ice4 = IceCream("Plain", 18)             # 0 + 18 = 18
ice5 = IceCream("ChocolateChip", 3)      # 5 + 3 = 8

sweetest_icecream([ice1, ice2, ice3, ice4, ice5]) ➞ 23
sweetest_icecream([ice3, ice1]) ➞ 23
sweetest_icecream([ice3, ice5]) ➞ 17

4. Возрастает или убывает

Написать функцию check_sequence, принимающую список целых чисел и возвращающую 1 если последовательность строго возрастающая, -1 если строго убывающая, 0 если ни то, ни другое.

Примеры вызовов и возвратов:

check_sequence([1, 2, 3]) ➞ 1
check_sequence([3, 2, 1]) ➞ -1
check_sequence([1, 2, 1]) ➞ 0
check_sequence([1, 1, 2]) ➞ 0 # потому что 1 по индексу 1 не больше 1 по индексу 0

Примечание: входящие списки содержат минимум 2 числа.

5. Пагинация

Создать класс Pagination, который обрабатывает некое содержимое постранично. Пагинация используется для того, чтобы делить длинные списки на как-бы на страницы.

Конструктор принимает два параметра:
items (по умолчанию: []): - список строкового содержимого, который мы будем пагинировать
page_size (по умолчанию: 10): кол-во экземпляров строк, показываемых на одной странице

Класс реализует функцию get_visible_items возвращающую элементы на текущей странице.

Класс также должен предоставлять набор функций для перемещения по страницам:

prev_page # переход на предыдущую страницу
next_page # переход на следующую страницу
first_page # переход на первую страницу
last_page # переход на последнюю страницу
go_to_page # принимает номер страницы в качестве аргумента, осуществляет переход на конкретную страницу            
           # если передано число > числа страниц, то перейти на последнюю, если < 1 то перейти на первую

Также, класс должен поддерживать следующие функции:

get_current_page возвращающая текущий номер страницы
get_page_size возвращающая размер страницы
get_items возвращающая список строк

Например, мы можем создать наш класс следующим образом:

alphabetList = list("abcdefghijklmnopqrstuvwxyz")

p = Pagination(alphabetList, 4)

А затем вызвать get_visible_items чтобы вывести содержимое текущей страницы (текущая страница - первая)

p.get_visible_items() ➞ ["a", "b", "c", "d"]

Если перейти на следующую страницу и снова вызвать get_visible_items, то получим ["e", "f", "g", "h"]

p.next_page()
p.get_visible_items() ➞ ["e", "f", "g", "h"]

На последней странице должно быть всего два элемента, так что если вызвать last_page и get_visible_items, то получим ["y", "z"]

p.last_page()
p.get_visible_items() ➞ ["y", "z"]

Notes:

Аргумент page_size и аргумент функции go_to_page передаются только типом int, не надо защищаться от float.

Функции перемещения по страницам должны быть реализованы таким образом, чтобы их можно было вызывать цепочкой: 
p.next_page().next_page().prev_page()p.last_page().prev_page()p.first_page().next_page()p.go_to_page(10).next_page()
