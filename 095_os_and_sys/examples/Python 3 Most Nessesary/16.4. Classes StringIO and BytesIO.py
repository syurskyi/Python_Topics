# # -*- coding: utf-8 -*-

# Класс stringIO из модуля io позволяет работать со строкой как с файловым объектом. Все
# операции с этим файловым объектом (будем называть его далее «файл») производятся
# в оперативной памяти. Формат конструктора класса:
# StringIO ( [<Начальное значеЮ1е>] [, newline=None])
# Если первый параметр не указан, то начальным значением будет пустая строка. После создания
# объекта указатель текущей позиции устанавливается на начало «файла». Объект, возвращаемый
# конструктором класса, имеет следующие методы:
# close () - закрывает «файл». Проверить, открыт «файл» или закрыт, позволяет атрибут
# closed. Атрибут возвращает True, если «файл» был закрыт, и False - в противном случае;
# + getvalue () - возвращает содержимое «файла» в виде строки:
# + tell () - возвращает текущую позицию указателя относительно начала «файла»;
# + see k ( <Смещение> [, <Позиция>] ) - устанавливает указатель в позицию, имеющую смещение
# <Смещение> относительно позиции <Позиция:>. В параметре <Позиция> могут быть
# указаны следующие значения:
#
# 0- начало «файла» (значение по умолчанюо);
# • 1 - текущая позици.я указателя;
# • 2- конец «файла».
# getvalue () - возвращает содержимое «файла» в виде строки
# write (<Строка>) - записывает строку в «файл»:
# writelines (<Последовательность>) - записывает последовательность в «файл»:
# read( [ <Количество символов>] ) -считывает данные из «файла». Если параметр не указан,
# то возврашается содержимое «файла» от текущей позиции указателя до конца «файла
# ». Если в качестве параметра указать число, то за каждый вызов будет возвращаться
# указанное количество символов. Когда достигается конец «файла», метод возвращает
# пустую строку.
# readline ( [ <Количество символов> J) - считывает из «файла» одну строку при каждом вызове.
# Возвращаемая строка включает символ перевода строки. Исключением является последняя строка - если она
# не завершается символом перевода строки, то символ перевода
# строки добавлен не будет. При достижении конuа «файла» возвращается пустая строка.
# Если в необязательном параметре указано число, то считывание будет выполняться до тех пор, пока не встретится
# символ новой строки (\n), символ конца «файла» или из «файла» не будет прочитано указанное количество символов.
# Иными словами, если количество символов в строке меньше значения параметра, то будет считана одна строка,
# а не указанное количество символов. Если количество символов в строке больше, то возвращается
# указанное количество символов.

# readlines ( [ <Примерное количество символов> J )
#
# считывает все содержимое «файла»
# в список. Каждый элемент списка будет содержать одну строку, включая символ перевода строки. Искточением является
# последняя строка - если она не завершается символом перевода строки, то таковой добавлен не будет.
#
# Если в необязательном параметре указано число, то считывается указанное количество символов nmoc фрагмент
# до символа конца строки \n. Затем эта строка разбивается и добавляется построчно в список.
# _next_ () - считывает одну строку при каждом вызове. При достижении конuа «файла
# » возбуждается исключение Stopiteration.
#
# Благодаря методу _next_ ( ) мы можем перебирать файл построчно с помощью цикла for.
# Цикл for на каждой итерации будет автоматически вызывать метод next ().
# f lush () - сбрасывает данные из буфера в «файл»;
# • truncate ( [ <Количество сиtv1Волов>]) - обрезает «файл» до указанного количества символов.
#
# Если параметр не указан, то «файл» обрезается до текущей позиции указателя
# Описанные ранее методы writable () и seekbe (), вызванные у объекта класса StringIO,
# всегда возвращают True.
# Класс StringIO работает только со строками. Чтобы выполнять аналогичные операции с «файлами»,
# представляющими собой последовательности байтов, следует использовать
# класс Bytesro из модуля io. Формат конструктора класса:
# BytesIO ( [ <Начальное значение>])
# Класс Bytesro поддерживает такие же методы, что и класс StringIO, но в качестве значений методы принимают
# и возвращают последовательноsти байтов, а не строки.
#
# Класс Bytesro поддерживает также метод getbuffer (), который возвращает ссылку на объект memoryview.
# С помощью этого объекта можно получать и изменять данные по индексу
# или срезу, преобразовывать данные в список целых чисел (с помощью метода tolist ()) или в последовательность байтов
# ( с помощью метода tobytes ( ).

import io              # Подключаем модуль
f = io.StringIO("String1\n")
f.getvalue()           # Получаем содержимое файла
# 'String1\n'
f.close()              # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\n")
f.tell()        # Позиция указателя
# 0
f.seek(0, 2)    # Перемещаем указатель в конец файла
# 8
f.tell()        # Позиция указателя
# 8
f.seek(0)       # Перемещаем указатель в начало файла
# 0
f.tell()        # Позиция указателя
# 0
f.close()       # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\n")
f.seek(0, 2)         # Перемещаем указатель в конец файла
# 8
f.write("String2\n")  # Записываем строку в файл
# 8
f.getvalue()         # Получаем содержимое файла
# 'String1\nString2\n'
f.close()            # Закрываем файл
# ######################################################################################################################

f = io.StringIO()
f.writelines(["String1\n", "String2\n"])
f.getvalue()         # Получаем содержимое файла
# 'String1\nString2\n'
f.close()            # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\n")
f.read()
# 'String1\nString2\n'
f.seek(0)  # Перемещаем указатель в начало файла
# 0
f.read(5), f.read(5), f.read(5), f.read(5), f.read(5)
# ('Strin', 'g1\nSt', 'ring2', '\n', '')
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2")
f.readline(), f.readline(), f.readline()
# ('String1\n', 'String2', '')
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\nString3\n")
f.readline(5), f.readline(5)
# ('Strin', 'g1\n')
f.readline(100)  # Возвращается одна строка, а не 100 символов
# 'String2\n'
f.close()       # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\nString3")
f.r..
# ['String1\n', 'String2\n', 'String3']
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\nString3")
f.r..(14)
# ['String1\n', 'String2\n']
f.seek(0)  # Перемещаем указатель в начало файла
# 0
f.r..(17)
# ['String1\n', 'String2\n', 'String3']
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2")
f.__next__(), f.__next__()
# ('String1\n', 'String2')
f.__next__()
# ... Фрагмент опущен ...
# StopIteration
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2")
for line in f:
    print(line.rstrip())

# String1
# String2
f.close()  # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\nString3")
f.truncate(15)     # Обрезаем файл
# 15
f.getvalue()       # Получаем содержимое файла
# 'String1\nString2'
f.close()          # Закрываем файл
# ######################################################################################################################

f = io.StringIO("String1\nString2\nString3")
f.seek(15)         # Перемещаем указатель
# 15
f.truncate()       # Обрезаем файл до указателя
# 15
f.getvalue()       # Получаем содержимое файла
# 'String1\nString2'
f.close()          # Закрываем файл
# ######################################################################################################################

import io             # Подключаем модуль
f = io.BytesIO(b"String1\n")
f.seek(0, 2)          # Перемещаем указатель в конец файла
# 8
f.write(b"String2\n")  # Пишем в файл
# 8
f.getvalue()          # Получаем содержимое файла
# b'String1\nString2\n'
f.seek(0)             # Перемещаем указатель в начало файла
# 0
f.read()              # Считываем данные
# b'String1\nString2\n'
f.close()             # Закрываем файл
# ######################################################################################################################

f = io.BytesIO(b"Python")
buf = f.getbuffer()
buf[0]                # Получаем значение по индексу
# b'P'
buf[0] = b"J"         # Изменяем значение по индексу
f.getvalue()          # Получаем содержимое
# b'Jython'
buf.tolist()          # Преобразуем в список чисел
# [74, 121, 116, 104, 111, 110]
buf.tobytes()         # Преобразуем в тип bytes
# b'Jython'
f.close()             # Закрываем файл
# ######################################################################################################################