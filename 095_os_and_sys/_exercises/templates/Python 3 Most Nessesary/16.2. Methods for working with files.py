# # # -*- coding: utf-8 -*-
#
# # Поскольку мы указали режим w, то если файл не существует, он будет создан, а если существует,
# # то будет перезаписан.
# # Текстовый режим
# # Открываем файл на запись
# # Записываем строку в файл
# # Закрываем файл
# # В параметре errors можно указать уровень обработки ошибок. Возможные значения:
# # "strict" (при ошибке возбуждается исключение ValueError - значение по умолчанию),
# # "replace" (неизвестный символ заменяется символом вопроса или символом с кодом
# # \ufffd), "ignore" (неизвестные символы игнорируются), "xmlcharrefreplace" (неизвестный
# # символ заменяется последовательностью &#хххх;) и "backslashreplace" (неизвестный символ
# # заменяется последовательностью \ uxxxx).
#
# w__ o___ _"file.txt" _ en.._"cp1251") a_ f
#     ?.w..("Строка")  # Записываем строку в файл
# # Здесь файл уже закрыт автоматически
#
# # Методы для работы с файлами
# # close ()
# #
# # закрывает файл. Так как интерпретатор автоматически удаляет объект, когда
# # на него отсутствуют ссылки, в небольших программах можно явно не закрывать файл.
# # Тем не менее, явное закрытие файла является признаком хорошего стиля программирования.
# # Кроме того, при наличии незакрытого файла генерируется предупреждающее сообщение:
# # "ResourceWarning: unclosed file".
#
# # write (<данные>)
# #
# # записывает строку или последовательность байтов в файл. Если
# # в качестве параметра указана строка, то файл должен быть открыт в текстовом режиме.
# # Для записи последовательности байтов необходимо открыть файл в бинарном режиме.
# # Помните, что нельзя записывать строку в бинарном режиме и последовательность байтов
# # в текстовом режиме. Метод возвращает количество записанных символов или байтов.
#
# # Текстовый режим
# f = o___ _"file.txt", _ en.._"cp1251"
# f.write("Строка1\nСтрока2")  # Записываем строку в файл
# # 15
# ?.cl..                # Закрываем файл
# # ######################################################################################################################
#
# # Бинарный режим
# f = o___ _"file.txt" __
# _.w.. by... "Строка1\nСтрока2" "cp1251"
# # 15
# # ######################################################################################################################
#
# ?.w.. b.a.("\nСтрока3", "cp1251"))
# # ######################################################################################################################
# # 8
# ?.cl.
#
# # При использовании текстового режима (задается по умолчанию) при чтении производится
# # попытка преобразовать данные в кодировку Unicode, а при записи выполняется обратная
# # операция - строка преобразуется в последовательность байтов в определенной кодировке.
# # По умолчаншо назначается кодировка, применяемая в системе. Если преобразование невозможно,
# # то возбуждается исключение. Указать кодировку, которая будет использоваться при
# # записи и чтении файла, позволяет параметр encoding.
#
# # writelines (<Последовательность>)
# #
# # записывает последовательность в файл. Если все
# # элементы последовательности являются строками, то файл должен быть открыт в текстовом
# # режиме. Если все элементы являются последовательностями байтов, то файл
# # должен быть открыт в бинарном режиме.
#
# # Текстовый режим
# f _ o___ _"file.txt" _ en.._"cp1251"
# ?.w.l. "Строка1\n", "Строка2"
# ?.cl..
# # Бинарный режим
# f _ o___ _"file.txt" __
# arr =  by..("Строка1\n", "cp1251"), by.. "Строка2", "cp1251"
# ?.w.l. ?
# ?.cl..
#
# # writable ()
# # - возвращает True, если файл поддерживает запись, и False - в противном случае:
#
# f _ o___ _"file.txt" _        # Открываем файл для чтения
# ?.w..
# # False
# # ######################################################################################################################
#
# f _ o___ _"file.txt", _        # Открываем файл для записи
# ?.w...
# # True
# # ######################################################################################################################
#
# # read ( [<Количество>] ) -
# #
# #  считывает данные из файла. Если файл открыт в текстовом
# # режиме, то возвращается строка, а если в бинарном - последовательность байтов. Если
# # параметр не указан, возвращает ся содержимое файла от текущей позиции указателя до
# # конца файла:
# # Если в качестве параметра указать число, то за каждый вызо в будет возвращаться указанное
# # количество символов или байт ов. Когда достигается конец файла, метод возв ращает
# # пустую строку
#
# # Текстовый режим
# w.. o___ _"file.txt", _ en.._"cp1251") a_ f
#     ?.r..
#
# 'Строка1\nСтрока2'
# # Бинарный режим
# w___ o___ _"file.txt" __ a_ f
#     ?.r..
# # b'\xd1\xf2\xf0\xee\xea\xe01\n\xd1\xf2\xf0\xee\xea\xe02'
# # ######################################################################################################################
#
# # Текстовый режим
# f _ o___ _"file.txt" _ en.._"cp1251"
# ?.r.. 8             # Считываем 8 символов
# # 'Строка1\n'
# ?.r.. 8               # Считываем 8 символов
# # 'Строка2'
# ?.r.. 8              # Достигнут конец файла
# # ''
# ?.cl..
# # ######################################################################################################################
#
# # readline ( [ <Количество> J )
# #
# # считывает из файла одну строку при каждом вызове. Если
# # файл открыт в текстовом режиме, то возвращается строка, а если в бинарном - последовательность
# # байтов. Возвращаемая строка включает символ перевода строки. Исключением
# # является последняя строка - если она не завершается символом перевода строки,
# # то таковой добавлен не будет. При достижении конца файла возвращается пустая строка.
# #
# # Если в необязательном параметре указано число, то считывание будет выполняться до
# # тех пор, пока не встретится символ новой строки {\n), символ конца файла или из файла
# # не будет прочитано указанное количество символов. Иными словами, если количество
# # символов в строке меньше значения параметра, то будет считана одна строка, а не указанное
# # количество символов, а если количество символов в строке больше, то возвращается
# # указанное количество символов.
#
# # Текстовый режим
# f _ o___ _"file.txt" _ en.._"cp1251"
# ?.r.. f.r..
# # ('Строка1\n', 'Строка2')
# # ######################################################################################################################
# # readline ( [ <Количество> J )
# #
# # считывает из файла одну строку при каждом вызове. Если
# # файл открыт в текстовом режиме, то возвращается строка, а если в бинарном - последовательность
# # байтов. Возвращаемая строка включает символ перевода строки. Исключением
# # является последняя строка - если она не завершается символом перевода строки,
# # то таковой добавлен не будет. При достижении конца файла возвращается пустая строка.
# #
# # Если в необязательном параметре указано число, то считывание будет выполняться до
# # тех пор, пока не встретится символ новой строки {\n), символ конца файла или из файла
# # не будет прочитано указанное количество символов. Иными словами, если количество
# # символов в строке меньше значения параметра, то будет считана одна строка, а не указанное
# # количество символов, а если количество символов в строке больше, то возвращается
# # указанное количество символов.
#
# ?.r..            # Достигнут конец файла
# ''
# ?.cl..
# # Бинарный режим
# f _ o___ _"file.txt" __
# ?.r.l., f.r.l.
# # (b'\xd1\xf2\xf0\xee\xea\xe01\n', b'\xd1\xf2\xf0\xee\xea\xe02')
# # ######################################################################################################################
#
# ?.r.l.           # Достигнут конец файла
# # b''
# # ######################################################################################################################
# ?.close
#
# f = o___ _"file.txt", _ en.._"cp1251"
# ?.r.l. 2, ?.r.l. 2
# # ('Ст', 'ро')
# # ######################################################################################################################
#
# ?.r.l. 100  # Возвращается одна строка, а не 100 символов
# # 'ка1\n'
# f.cl..
# # ######################################################################################################################
# # readlines ( ) -
# #
# # считывает все содержимое файла в список. Каждый элемент списка будет
# # содержать одну строку, включая символ перевода строки. Исключением является
# # последняя строка. Если она не завершается символом перевода строки, то символ перевода
# # строки добавлен не будет. Если файл открыт в текстовом режиме, то возвращается
# # список строк, а если в бинарном - список объектов типа bytes.
#
# # Текстовый режим
# w___ o___ _"file.txt", _ en.._"cp1251") a_ f
#     ?.r.l.
# # ['Строка1\n', 'Строка2']
# # ######################################################################################################################
#
# # Бинарный режим
# w___ o___ _"file.txt", __ a_ f
#     ?.r.l.
#
# # [b'\xd1\xf2\xf0\xee\xea\xe01\n', b'\xd1\xf2\xf0\xee\xea\xe02']
# # ######################################################################################################################
# # _next_ ()
# #
# # считывает одну строку при каждом вызове. Если файл открыт в текстовом
# # режиме, возвращается строка, а если в бинарном - последовательность байтов. При
# # достижении конца файла возбуждается исключение stopiteration.
# #
# # Благодаря методу _next_ ( ) мы можем перебирать файл построчно с помощью цикла
# # for. Цикл for на каждой итерации будет автоматически вызывать метод _next_(). Для
# # примера выведем все строки, предварительно удалив символ перевода строки:
#
# # Текстовый режим
# f _ o___ _"file.txt", _ en.._"cp1251"
# ?. -n, ?. -n
# # ('Строка1\n', 'Строка2')
# # ######################################################################################################################
#
# ?. -n  # Достигнут конец файла
# # Traceback (most recent call last):
# #   File "<pyshell#26>", line 1, in <module>
# #     f.__next__() # Достигнут конец файла
# # StopIteration
# ?.cl..
# # ######################################################################################################################
#
# f _ o___ _"file.txt" _ en.._"cp1251")
# ___ line i_ f
#     print ?.rst..("\n"), e.._" "
# # Строка1 Строка2
# ?.cl..
# # ######################################################################################################################
#
# # flush () - принудительно записывает данные из буфера на диск;
# # fileno () - возвращает целочисленный дескриптор файла. Возвращаемое значение всегда будет больше числа 2, т . к.
# # число О закреплено за стандартным вводом stdin, l - за стандартным выводом stdout, а 2 - за стандартным выводом
# # сообщений об ошибках stderr.
#
# f _ o___ _"file.txt", _ en.._"cp1251"
# ?.f..n.                  # Дескриптор файла
# # 3
# ?.cl..
# # ######################################################################################################################
#
# f = o___ _"file.txt", _ en.._"cp1251")
# ?.r..
# # 'Строка1\nСтрока2'
# # ######################################################################################################################
# # truncate ([<Количество>])
# #
# # обрезает файл до указанного количества символов (если задан текстовый режим) или байтов (в случае бинарного режима).
# # Метод возвращает новый размер файла.
#
# ?.tru.. 5
# # 5
# ?.cl..
# # ######################################################################################################################
#
# w____ o___ _"file.txt" _ en.._"cp1251") a_ f
#     _.r..
# # 'Строк'
# # ######################################################################################################################
#
# w))) o___ _"file.txt", _ en.._"cp1251") a_ f
#         ?.w...("String1\nString2")
#
# # 15
# # ######################################################################################################################
# # te.. - возвращает позицию указателя относительно начала файла в виде целого числа.
# # Обратите внимание на то, что в Windows метод tell () считает символ \r как дополнительный
# # байт, хотя этот символ удаляется при открытии файла в текстовом режиме.
#
# f _ o___ _"file.txt" _ en.._"cp1251"
# ?.te..     # Указатель расположен в начале файла
# # 0
# # ######################################################################################################################
#
# ?.r.l.  # Перемещаем указатель
# # 'String1\n'
# # ######################################################################################################################
#
# ?.te..      # Возвращает 9 (8 + '\r'), а не 8 !!!
# # 9
# # ######################################################################################################################
# ?.cl..
#
#
# f = o___ _"file.txt" __
# ?.r.l.  # Перемещаем указатель
# # b'String1\r\n'
# # ######################################################################################################################
#
# ?.te..      # Теперь значение соответствует
# # 9
# ?.cl..
# # ######################################################################################################################
# # se.. ( <Смещение> [, <Позиция>] )
# #
# # устанавливает указатель в позицию, имеющую смещение
# # <Смещение> относительно позиции <Позиция>. В параметре <Позиция> мoryr быть
# # указаны следующие атрибуты из модуля io или соответствующие им значения:
# # • io.SEEK_SET или о- начало файла (значение по умолчанию);
# # • io. se.. _ cuR или 1 - текущая позиция указателя. Положительное значение смещения
# # вызывает перемещение к концу файла, отрицательное - к его началу;
# # • io. se.. _ END или 2 - конец файла.
# # Выведем значения этих атрибутов:
#
# _______ i_
# i_.SE._S. i_.SE._C. i_.S._E.
# # (0, 1, 2)
# # ######################################################################################################################
#
# ______ i_
# f = o___ _"file.txt" __
# ?.se.. 9, i_.S.._C..  # 9 байтов от указателя
# # 9
# # ######################################################################################################################
#
# ?.te..
# # 9
# # ######################################################################################################################
# ?.se.. 0 i_.S._S.  # Перемещаем указатель в начало
# # 0
# # ######################################################################################################################
# ?.te..
# # 0
# # ######################################################################################################################
# ?.se.. -9 i_.S.._E.  # -9 байтов от конца файла
# # 7
# # ######################################################################################################################
# ?.te..
# # 7
# # ######################################################################################################################
# ?.cl..
#
# # seekabe ()
# #
# # возвращает True, если указатель файла можно сдвинуть в друrую позицmо,
# # и False - в противном случае:
#
# f _ o___ _"C:\temp\new\file.txt" _
# ?.s..a..
# # True
# # ######################################################################################################################
# # Помимо методов, объекты файлов поддерживают несколько атрибутов:
# # + name - имя файла;
# # + mode - режим, в котором был открыт файл;
# # + closed - возвращает True, если файл был закрыт, и False - в противном случае.
#
# f _ o___ _"file.txt", __
# ?.na.. ?.mo.. ?.cl..
# # ('file.txt', 'rb+', False)
# # ######################################################################################################################
# ?.cl..
# ?.cl..
# # True
# #
# # ######################################################################################################################
# # encoding -
# # название кодировки, которая будет использоваться для преобразования строк перед записью в файл или при чтении.
# # Атрибут доступен только в текстовом режиме.
# # Обратите также внимание на то, что изменить значение атрибута нельзя, поскольку он доступен только для чтения.
# #
# # Стандартный вывод stdout также является файловым объектом. Атрибут encoding этого объекта всегда содержит кодировку
# # устройства вывода, поэтому строка преобразуется
# # в последовательность байтов в правильной кодировке. Например , при запуске с помощью двойного щелчка на значке файла
# # атрибут encoding будет иметь значение "ср866", а при запуске в окне Python Shell редактора IDLE - значение " ср1251 ".
#
# f _ o___ _"file.txt", _ en.._"cp1251"
# ?.en...
# # 'cp1251'
# # ######################################################################################################################
# ?.cl..
#
# ________ ___
# ___.s..o_.en..
# # 'cp1251'
# # ######################################################################################################################
# # buffer -
# # позволяет получить доступ к буферу. Атрибут доступен только в текстовом
# # режиме. С помощью этого объекта можно записать последовательность байтов в текстовый
# # поток.
#
# ? _ o___ _"file.txt", _ en.._"cp1251"
# ?.bu___.w.. by.. ("Строка", "cp1251"))
# # 6
# ?.cl..